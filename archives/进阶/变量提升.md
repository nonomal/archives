## 认知

**传统编译流程**

1.分词/词法分析，将源代码处理为词法单元。
2.解析/语法分析，利用上一步生成的词法单元流组合生成抽象语法树（AST）。
3.将 AST 转换为目标平台可执行的代码。

**以var a = 2为例**

1.**引擎** 通知 **编译器** 开始执行 `var a = 2` 的编译工作。

2.**编译器** 在编译的过程中，发现需要声明一个名为 `a` 的标识符，此时它就会通知 **作用域** 进行查找。如果当前作用域集合中已经存在相同名称的标识符，编译器会忽略本次声明操作继续编译；否则它会要求在当前作用域集合中生成一个新的标识符，并命名为 `a`。

3.编译结束后，**编译器** 会将可执行代码提供给 **引擎** 。在运行过程中，**引擎** 发现需要对标识符 `a` 进行赋值。**引擎** 就会询问 **作用域** 是否能查找到名为 `a` 的标识符，查找成功引擎就将 2 赋值给 `a`，失败则抛出异常。

## 变量提升

在 JavaScript 中所有的声明会“移动”到各自作用域的顶端，我们将这种现象称为 **变量提升** ，它的实际原理就在于 JavaScript 代码在 **编译阶段** 就将 **声明** 这个动作完成了。

不同类型标识符提升的特点：

- 普通变量只会提升声明部分并将被为其赋初值为 `undefined` ，当提前使用该变量时将返回 undefined 。
- 函数声明属于完全提升，所以代码中允许在 **函数声明** 之前发生 **函数调用** 。

```js
console.log(a) // undefined

var a = 2

foo() // success

function foo() {
  console.log('success');
}
```

## LHS 、RHS（查找标识符的两种方式）

- LHS，可以理解为对标识符的 **内存地址** 的查询。
- RHS，可以理解为对标识符所存储的 **值** 的查询。

注：LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。说白了就是变量出现在复制操作的左边是进行LHS查询，出现在右边就是进行RHS查询。通常会抛出`ReferenceError`异常的就是`RHS`查询无果。

```js
let a = b 
VM240:1 Uncaught ReferenceError: b is not defined
    at <anonymous>:1:9

let c 
undefined
```

以下面代码为例,以下代码主要经历了两次2 次 **LHS** 和 2 次 **RHS**，实际执行过程如下：

```js
function foo(a) {
  var b = a
}

foo(2)
```

- 当需要调用 `foo` 函数时，**引擎** 会执行 **RHS** 查询 `foo` 的值。

- 当 `foo` 函数在执行时，为了给型参 `a` 进行赋值会执行 **LHS** 查询标识符 `a` 的内存地址，并将 2 赋值给 `a`。

- 当执行 `var b = a` 语句时，**引擎** 会执行对标识符 `a` 的值的 **RHS** 查询，以获取值 2。然后对标识符 `b` 执行 **LHS** 查询得到内存地址后，将 2 赋值给 `b`。


## 异常

在 JavaScript 中作用域是可以相互 嵌套 的，最外层的作用域被称为 全局作用域 。当引擎执行查询操作时，如果在当前的作用域中无法查找到相应的标识符就会向外层的作用域前进，直到查询成功就停止。假如一直到全局作用域当中都查询不到，此时引擎就会抛出 ReferenceError 异常

LHS 查询与 RHS 查询在查找不到标识符时的区别：

- RHS 查询与一开始我们所讲的规则是一致的，当一路查询到全局作用域中都没有结果时就会抛出异常。
- LHS 查询稍有不同，在 严格模式 下抛出异常的规则和上述的一致。但是在 非严格模式 下查询不到结果时，引擎会在全局作用域中创建一个同名的标识符。


## 例题

```js
console.log(v1);
var v1 = 100;
function foo() {
    console.log(v1);
    var v1 = 200;
    console.log(v1);
}
foo();
console.log(v1);


//	结果
// undefined
// undefined
// 200 
// 100
```

## 声明方式的变量提升区别

- let 的「创建」过程被提升了，但是初始化没有提升。
- var 的「创建」和「初始化」都被提升了。
- function 的「创建」「初始化」和「赋值」都被提升了。
- 函数的声明会将声明和赋值都提前，但字面量的声明和提升和普通变量的结果一样

## 优先级

函数和变量同名的时候，变量未赋值的情况下，函数声明优先级高于变量声明。另外，参数的优先级别大于变量声明（函数声明>参数>变量声明）

## 低版本环境和高版本环境的区别

```js
foo(); //低版本：2  //高版本： Uncaught TypeError: foo is not a function
 
var a = true;
 
if(a){
    function foo () { console.log(1); }
}else{
    function foo () { console.log(2); }
}
```




知识来源

- [前端面试之JavaScript基础（三）—— 作用域](https://juejin.cn/post/6933858483905396749)
- [浅谈JS变量提升](https://zhuanlan.zhihu.com/p/100563316)

