### 相关文章

[详解http协议](https://www.cnblogs.com/AhuntSun-blog/p/12529920.html)

### 一次完整的HTTP事务流程

（1）域名解析

（2）发起TCP的三次握手

（3）建立TCP连接后发起http请求

（4）服务器响应http请求，浏览器得到HTML代码

（5）浏览器解析HTML代码，并请求HTML代码中的资源

（6）浏览器对页面进行渲染呈现给用户

（7）连接结束 （四次挥手）

### 术语解释

> SYN ：同步序列编号（*Syn*chronize Sequence Numbers）
>
> 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1

> ACK ：确认字符 (*Ack*nowledge character）
>
> 确认号是否有效，一般置为1。由目的端发出

> FIN ：断开连接的四次握手时的标志（finish）
>
> 希望断开连接。提出断开连接的一方将其置为1

> URG ：紧急位（urgent）
>
> 紧急指针是否有效。为1，表示某一位需要被优先处理。

> PSH ：推位（push）
>
> 提示接收端应用程序立即从TCP缓冲区把数据读走。

> RST（reset）
>
> 对方要求重新建立连接，复位。

### **TCP三次握手？四次挥手？**

三次握手要确认双方的两样能力：`发送能力与接收的能力`。 

三次握手的必要性：为了保证服务器能接收到客户端的信息并做出正确的应答而进行前两次（第一次和第二次）握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次（第二次和第三次）握手。

![](https://img-blog.csdn.net/20180306090528688)

上图部分标志说明：

（1）ACK：TCP规定，只有当ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

（2）SYN（SYNchronization）：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这个是一个连接请求报文。对方若同意建立连接，则响应报文中SYN=1，ACK=1。因此，SYN置1表示这是一个连接请求或连接接受报文。

（3）FIN（finish）：终结的意思，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并请求释放连接。

**三次握手说明：**

（1）第一次握手：建立连接。客户端发送连接请求报文段，将`SYN(同步序列号)`位置1，序列号seq（sequence number）为x（随机数）；然后，客户端进入`SYN_SEND`状态，等待服务器的确认。

> 一句话：`客户端向服务器发送一个含有同步序列号的标志位，向服务器请求建立连接`
>

（2）第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，ACK位置1，确认号ack（acknowledgement number）为`x+1`；同时，自己还要发送SYN请求信息，将SYN位置1，序列号seq为y；服务器将上述SYN+ACK报文段一并发送给客户端，此时服务器进入SYN_RECV状态。

> 一句话：`服务器收到请求后，用一个含有确认应答和同步序列号标志位的数据段响应客户端，表示已接收请求`

（3）第三次握手：客户端收到服务器的SYN+ACK报文段。然后将确认号ack设置为`y+1`，向服务器发送ACK报文段。这个报文段发送完毕后，客户端和服务器都进入ESTABLISHED状态，完成TCP三次握手，之后可以开始传数据。

> 一句话：`客户端收到服务器的数据段后，再次发送确认应答，表示可以传输数据`

**三次握手的特点**：没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。

### 什么是半链接队列

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

Ps:全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### 三次握手过程中可以携带数据吗？

第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据。



**四次挥手：**

当客户端和服务器通过三次握手建立了TCP连接之后，当数据传输完毕，就要断开TCP连接，这个过程称为四次挥手。四次挥手说明：

（1）第一次挥手(FIN=1，seq=x)
假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，发送完毕后，客户端进入 `FIN_WAIT_1` 状态。`表示自己已经没有数据可以发送了，但是仍然可以接受数据。`

> 一句话：`当客户端完成数据传输后，将控制位FIN置为1，提出断开TCP的请求`

（2）第二次挥手(ACK=1，ACKnum=x+1)
服务器端确认客户端的 FIN 包，发送一个确认包，`表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。`
发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

> 一句话：`当服务器收到FIN后对其做出响应，确认这一方向上的TCP即将关闭，将ACK置为1`

（3）第三次挥手(FIN=1，seq=y)
`服务器端准备好关闭连接时，向客户端发送结束连接请求`，FIN 置为1。
发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

> 一句话：`服务器提出反方向关闭请求，将FIN置为1`

（4）第四次挥手(ACK=1，ACKnum=y+1)
`客户端接收到来自服务器端的关闭请求，发送一个确认包`，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。
`服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。`

> 一句话：`客户端对服务器的请求进行确认，将ACK置为1,双方的关闭结束`

客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

### **HTTP请求码及其作用？**

[http状态码详解](<https://tool.oschina.net/commons?type=5>)

HTTP状态码：当用户访问一个网页时，浏览器会向网页所在的服务器出请求，当浏览器接收并显示网页前，此网页所在服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求，HTTP状态码用于描述服务器对请求的处理结果。

HTTP状态码分类：

（1）1**：信息，服务器收到请求，需要请求者继续执行操作

（2）2**：成功，操作被成功接收并处理

（3）3**：重定向，需要进一步的操作以完成请求

（4）4**：客户端错误，请求包含语法错误或者无法完成请求

（5）5**：服务器错误，服务器在处理请求的过程中发生了错误

常见的HTTP状态码：

- 200——OK，请求成功
- 301——Moved Permanently，资源（网页等）被永久转移到其他URL
- 302——Found，307——Temporary Redirect，临时重定向，请求的文档被临时移动到别处 
- 304——Not Modified，未修改，表示客户端缓存的版本是最近的 💛
- 401——Unauthorized，请求要求用户的身份认证
- 403——Forbidden，禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致
- 404——Not Found，请求的资源（网页等）不存在
- 500——Internal Server Error——内部服务器错误
- 502——Bad Gateway，充当网关或代理的服务器从远端服务器接收到了一个无效的请求
- 504——Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求

### 重定向 3XX详解

**301永久性转移**

搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。

sample.com/a 301 到 sample.com/b 

因为是 301 永久重定向，这个意思就是 a 链接已经没有存在的意义了，他所有的价值都会导向给 b。

所以对于搜索引擎来说 b 链接就是 a 链接了现在。所以 a 链接的权重会直接传递给 b 链接。这也就是常说的 301 对 SEO 有好处的原因。

而且 301 也是谷歌官方认为是将[网站地址由 HTTP 迁移到 HTTPS 的最佳方法](https://support.google.com/webmasters/answer/6073543)。

场景是：例如你的网站换了地址了，之前的地址不用了，若用户还是从之前的地址进的话则会返回`301`且在`Location`中带上最新的URI。且浏览器默认会做缓存优化，减少服务器压力，在第二次访问的时候自动访问重定向的那个地址。

**302临时性转移**

搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。

规定 302 重定向不允许修改请求方式。也就是当一个 POST 请求返回了 302 时，按照规范仍然应该使用 POST 请求打开响应头中 Location 中的 URl。

但各家浏览器厂商在实现的时候并没有遵守这个规范，而是使用 GET 方式访问服务端响应头中的 Location 中的 URI。

只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

**304 未修改**

所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

**总结**

301比较常用的场景是使用域名跳转。302用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。

### 浏览器解析渲染过程？

（1）浏览器解析HTML源码，然后创建一个DOM树。

在DOM树中，每一个HTML标签都有一个对应的节点（元素节点），并且每一个文本也都有一个对应的文本节点，DOM树的根节点就是documentElement，对应的是html标签

（2）浏览器解析CSS代码，然后创建一个CSSOM树。

解析CSS的时候会按照如下顺序来定义优先级（递增）：浏览器默认设置<用户设置<外联样式<内联样式<标签样式

（3）根据DOM树和CSSOM来构建一个渲染树（render tree）。

（4）当渲染树创建完成之后，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

### **为什么要先引入css文件，再引入js文件？**

（1）js代码的下载是阻塞下载，不可以和其他代码并行下载和解析；CSS的加载不会阻塞DOM树的解析（会阻塞其渲染，也会阻塞后面的js执行）

（2）页面加载时，是按照从上到下，从左到右的顺序加载的。如果将js放在前面，会立即执行，阻塞后续的资源下载和执行。如果外部脚本加载时间过长，会造成网页长时间失去响应，浏览器就会呈现“假死”状态（阻塞效应）

（2）页面需要等到head中的js和css加载完成之后才开始绘制，当js放在body最后时，不需要等待，可以避免资源阻塞，同时使静态页面迅速显示

（3）部分js的执行依赖于前面的样式。

（4）js一般是处理功能，所以不需要提前加载。先给用户观感，在给用户上手体验。

### http各版本区别

- `HTTP/0.9 `  1991

> 只支持`GET`命令，服务器只能回应`HTML`字符串，没有其他格式  

```js
<html>
  <body>Hello World</body>
</html>
```

> 服务器发送完毕就关闭`TCP`连接

- `HTTP/1.0`  1995

> 任何格式的内容都可以发送

> 增加了`POST`和`HEAD`命令

> HTTP请求和回应的格式也变了,除了通信部分之外，还必须包括头信息，用来描述元数据

> 新增状态码、支持多字符集、多部分发送、权限、缓存、内容编码

请求格式示例：

```js
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

回应格式内容示例：

```js
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

**Content-Type**

- text/plain
- text/html
- text/css
- image/jpeg
- image/png
- image/svg+xml
- audio/mp4
- video/mp4
- application/javascript
- application/pdf
- application/zip
- application/atom+x

**Content-Encoding**

```http
Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
```

**该版本缺点**

每个`TCP`连接只能发送一个请求，发送数据完毕，连接就关闭，极大的浪费了服务器资源，每次新建连接的成本都很高，为了解决这个问题，有些浏览器采用了非标准的`Connection`字段，这个字段表示要求服务器不要关闭资源，这样虽然一个可以复用的`TCP`连接了，但是由于像客户端与服务器时间不一致，会产生行为的不一致性，所以也并没有从根本上解决问题。

- `HTTP/1.1`  1997   到现在还是最流行的版本

**持久连接**

> 引入了持久连接，`TCP`第一次连接默认不关闭，可以被多个请求复用，不用声明：`Connection:keep-alive`,客户端和服务器发现对方一段时间没有活动就可以关闭连接。
>
> 规范的做法：客户端在最后一次请求时`Connection:close`,明确要求服务器关闭连接

目前对于同一个域名，大多数浏览器允许同时建立6个连接

**管道机制**

同一个`TCP`请求里，客户端可以发送多个请求

**分块传输编码**

只要请求头或响应头信息有`Transfer-Encoding`字段，表明回应由数量为定的数据块组成

> Transfer-Encoding: chunked

**其他功能**

新增了：`PUT` `PATCH` `HEAD` `OPTIONS` `DELETE`方法

请求头信息新增了`Host`字段，指定服务器的域名

**该版本缺点**

> 多条TCP连接带宽竞争

> 虽然该版本支持复用`TCP`请求，但所有的数据通信还是按次序进行的，只有服务器处理完上一个回应，才会进行下一个回应，要是前面的回应特别慢就会由许多请求排队等着,这种称为`队头堵塞`

为了避免该版本的缺点，只有两种方法：一是减少请求数，二是同时多开持久化连接，所以产生了很多网页优化技巧，比如合并脚本和样式表，将图片前途css代码、`域名分片`等

`域名分片`:把静态资源划分出多个独立的域名进行并发请求

- `HTTP/2` 2015 

**二进制传输**

HTTP/2 采用二进制格式传输数据，而非HTTP/1.1 里纯文本形式的报文 ，二进制协议解析起来更高效。

**Header压缩**

HTTP/1.1的header带有大量信息，而且每次都要重复发送，HTTP/2并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

**多路复用**

多路复用允许同时通过单一的HTTP/2连接发起多重的请求-响应信息，很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。

**Server Push**

在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push）。

- `HTTP/3` 2018/10

### HTTP和HTTPS的区别

HTTP（Hyper Text Transfer Protocol，超文本传输协议）被用于在web浏览器和网站服务器之间传递信息，HTTP协议以`明文`的方式发送内容，不提供任何方式的数据加密，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号，密码等支付信息。

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer，安全套接字超文本传输协议），为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS，依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。其中SSL（Secure Socket Layer，安全套接层），TLS（Transport Layer Securit，传输层安全协议），SSL 3.0和TLS 1.0差别很小，在HTTPS通信中具体使用哪一个还要看客户端和服务端的支持程度，二者在网络模型中位于哪一层？

区别：

（1）HTTPS协议需要CA申请证书，一般免费证书比较少，所以需要一定费用

（2）HTTP是超文本传输协议，信息室明文传输，HTTPS则是具有安全性的SSL加密传输协议

（3）HTTP和HTTPS使用的是完全不同的连接方式，使用的端口号也不一样，前者是80，后者是443

（4）HTTP连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，比较安全。

（5）谷歌搜索引擎算法中，比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中排名会更高


### **客户端使用HTTPS方式与web服务器通信的步骤：**

（1）客户使用HTTPS的URL访问web服务器，要求与web服务器建立SSL连接(将自己支持的一套加密规则发送给网站)

（2）web服务器收到客户端请求后，将网站的证书信息（证书中包含公钥）传送一份给客户端

（3）客户端的浏览器与web服务器开始协商SSL连接的安全等级，也就是信息的加密等级

（4）客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传送给网站

（5）web服务器利用自己的私钥解密出会话秘钥

（6）web服务器利用会话秘钥加密与客户端之间的通信

### **浏览器同源策略**

（1）浏览器安全的基石是“同源策略”（same-origin policy）。所谓“同源”指的是“三个相同”：

- 协议相同
- 域名相同
- 端口相同

（2）同源策略的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。

 （3）如果非同源，共有三种行为受到限制：

- Cookie、LocalStorage和IndexDB无法读取
- DOM无法获得
- AJAX请求不能发送

（4）不受同源策略限制的：

- 页面中的链接，重定向以及表单提交
- 跨域资源的引入是可以的，但是js不能读写加载的内容。（如<script src=...></script>，<img>，<link>，<iframe>）

### 长链接和短链接

#### 短链接

完成一次通信之后，客户端主动断开TCP连接；

`HTTP/1.0`中，默认使用的是**短连接**。也就是说，浏览器和服务器每进行一次`HTTP`操作，就建立一次连接（三次握手），结束就中断（四次挥手）；

#### 长链接

完成一次通信之后，客户端不主动断开 `TCP`连接，而是复用该`TCP`连接；

`HTTP/1.1`起，默认使用**长连接**，用以保持连接特性。此时通用首部字段中的`Connection`字段值为：`Keep-Alive`；

长连接适用于频繁地传输数据的客户端和服务器，为了防止过多的TCP连接影响服务器性能，需要对长时间不用的连接进行释放；

### 缓存工作方式（强缓存和协商缓存）

1. 场景一：

让服务器与浏览器约定一个文件过期时间————`Expires`，在`Expires`没有过期的情况下，客户端发出请求时，直接使用HTTP本地缓存并返回200，这种方式称为`强制缓存`

2. 场景二：

让服务器在与浏览器在约定文件过期时间`Expires`的基础上，再加一个文件最新修改时间的对比————`Last-Modified`与`If-Modified-Since`

- 情况1：如果`Expires`没有过期，直接采用强制缓存
- 情况2：如果`Expires`过期了，那么浏览器在请求服务器的时候，就带上了文件最新修改时间，这个字段是在请求头上面加了`Is-Modified-Since`字段，其实该字段的值就是上次请求时服务器返回的`Last-Modified`值；服务器会把请求头里的`If-Last-Modified`的值与服务器上的文件最新修改时间`Last-Modified`的值进行比较
  - 如果`If-Modified-Since` **不等于**`Last-Modified`，说明浏览器缓存的资源（`f.js`）发生改变，服务器就会去查找最新的`f.js`，同时再次返回`Expires`、`f.js`、`Last-Modified`，返回的状态码为`200`;
  - 如果`If-Modified-Since` **等于**`Last-Modified`，说明浏览器缓存的资源（`f.js`）没有发生改变，浏览器可以继续使用`HTTP`本地缓存，此时服务器返回状态码`304`；这种方式称为**协商缓存**

3. 场景三：

让服务器在过期时间`Expires`+`Last-Modified`的基础上，增加一个文件唯一标识`Etag`与`If-None-Match`配成一对使用；除此之外，`Expires`不稳定，再加入一个`Max-age`来加以替代（`Max-age`优先级更高）

- 在60s内，浏览器不再向服务器发起请求，直接使用本地缓存这与`Expires`相似。
- 60s后：浏览器带上`If-Modified-Since`和`If-None-Match`（也就是上次服务器返回的`Etag`值）发起请求，服务器会对比`If-None-Match`与服务器端的`Etag`值，这时即使浏览器也提供了`If-Modified-Since`也不会再与`Last-Modified`进行对比，因为`Etag`的优先级比`Last-Modified`高（更精准）；
  - 如果`If-None-Match`**不等于**`Etag`，说明`f.js`文件已被修改，服务器就会返回最新的`f.js`和全新的`Etag`与`Max-age`（比如`60`），当然也会顺便把`Expires`与`Last-Modified`返回（尽管没用）；返回的状态码为`200`；
  - 如果`If-None-Match`**等于**`Etag`，说明`f.js`文件没有被修改，这时服务器返回的状态码为`304`，告诉浏览器继续使用原来的本地缓存。这种方式属于**协商缓存**；

**有了Last-Modified为什么还要用Etag呢？**

你可能会觉得使用`Last-Modified`已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要`Etag`呢？`HTTP1.1`中`Etag`的出现主要是为了解决几个`Last-Modified`比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新`GET`；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说`1s`内修改了`N`次)，`If-Modified-Since`能检查到的粒度是`s`级的，这种修改无法判断（比如淘宝每`ms`都会更新数据）；
- 某些服务器不能精确的得到文件的最后修改时间；

这时，利用`Etag`能够更加准确的控制缓存，因为`Etag`是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。 `Last-Modified`与`ETag`是可以一起使用的，服务器会优先验证`ETag`，一致的情况下，才会继续比对`Last-Modified`，最后才决定是否返回`304`。

#### 强制缓存和协商缓存区别

- 强制缓存：直接使用`http`本地缓存，此时服务器返回状态码时200

  >  强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。强缓存又分为两种`Expires`和`Cache-Control` 

- 协商缓存：向服务器确认`http`本地缓存的资源是否发生变化，没变化后再使用`http`本地缓存，此时服务器返回状态时304；资源发生变化直接返回最新资源，状态码为200；可以这样理解凡是304状态码，都属于`协商缓存`

  > 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

请求头`Cache-control`的值为no-cache时表示浏览器会向服务器确认缓存的新鲜度，再决定是否使用缓存，属于`协商缓存`

浏览器操作对缓存的影响

|   用户操作    | Expires/Cache-Control | Last-Modified/Etag |
| :-----------: | :-------------------: | :----------------: |
|  地址栏回车   |         有效          |        有效        |
| 页面链接跳转  |         有效          |        有效        |
|   新开窗口    |         有效          |        有效        |
|  前进、后退   |         有效          |        有效        |
|    F5刷新     |       **无效**        |        有效        |
| Ctrl + F5刷新 |       **无效**        |      **无效**      |

### 流程图

![](https://user-images.githubusercontent.com/25027560/38223505-d8ab53da-371d-11e8-9263-79814b6971a5.png)



### HTTP哪些请求头跟缓存相关

缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。

强缓存相关字段有`expires`、`che-control`。如果`cache-control`与`expires`同时存在的话，`cache-control的优先级高于`expires`。

协商缓存相关字段有`Last-Modified/If-Modified-Since`，`Etag/If-None-Match`

### cache-control的值有哪些

常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。

### 关于http中的keep-alive	

> 在http早期，每一个http请求都要打开一个tcp socket 连接，并且使用一次后就会断开连接。使用keep-alive可以改善这种状态，减少tcp请求次数，减少TIME_WAIT状态连接，以此提高性能和httpd服务器的吞吐率，但是keep-alive并不代表可以永久使用，长时间容易导致系统资源无效占用，比重复利用连接带来的损失还要大，所以要正确设置keep-alive的时间。

### 304的过程描述

- 浏览器请求资源时首先会命中`Expores`和`Cache-control`,`Expires`受限于本地时间，如果修改了本地时间，会造成缓存失效，可以通过`Cache-control:max-age`指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器能看到`from-cache`字样。
- 强制缓存失效的情况下，进入协商缓存，首先验证`Etag`,其可以保证每个资源是唯一的，资源变化都会导致`Etag`变化。服务器根据客户端上送的`If-None-Match`值来判断是否命中缓存。
- 协商缓存`Last-Modify/If-modify-Since`阶段，客户端第一次请求资源时，服务器返回的`header`里会加上`Last-Modify`,`Last-Modify`是一个时间表示该资源的最后修改时间。再次请求资源时，`request`的请求头中会包含`If-Modify-Since`,该值是之前返回的`Last-Modify`,服务器收到`If-Modify-Since`之后，根据资源的最后修改时间判断是否命中。

### UDP（User Data Protocol，用户数据报协议）

1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。

3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。

5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

### TCP和UDP的区别

1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。    

### HTTP存在的位置

处于TCP/IP网络分层模型中的应用层

TCP/IP的`OSI`模型有：物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。

应用层其他协议还有：

- FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件。

- DNS域名系统：提供域名到IP地址之间的解析服务。

- SMTP：邮件发送协议，用户通过SMTP服务器发送邮件。

- DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址。

- POP3：邮件接收协议，用于从POP3服务器接收邮件。

### HTTP的特点 

- 客户端/服务端模式，也是一种请求/响应模式的协议
- 灵活可扩展：一是语义上的自由，只规定了基本格式，其他部分没有严格限制；二是允许传输任何类型的数据对象
- 可靠传输：HTTP基于TCP/IP，具有TCP/IP协议的可靠性
- 无状态：不具备保存之前发送过的请求或响应的功能。每一次请求都是独立的
- 持久连接：1.1版本开始所有的连接默认都是持久连接的

### HTTP的缺点

- 明文传输，内容可能被窃听
- 无法验证报文完整性，可能会被篡改
- 不验证通信方身份，可能遭遇伪装
- 无状态（有些长链接需要保存上下文信息，以免传输重复的数据）
- 队头阻塞（前面的请求没有响应，后面的请求就会被阻塞）

**队头阻塞**

队头阻塞： 

- 其根本原因在于HTTP是基于 请求-响应 的模型，在同一个TCP长连接中，前一个请求没有得到响应，后面的请求就会被阻塞。
- 用并发连接 和 域名分片 来解决了这个问题。但并不是从HTTP本身的层面来解决的，只是增加了 TCP 连接，分摊风险而已。
- HTTP/2中的多路复用从HTTP本身的层面解决了这个问题
- 和TCP队头阻塞的区别：TCP传输的单位是数据包，它的队头阻塞表示的是前一个报文没有收到便不会将下一个报文上传给HTTP。而HTTP队头阻塞是在 请求-响应 层面，前一个请求还没有处理完，后面的请求就被阻塞。

### HTTP请求方法

GET：获取资源，幂等操作

HEAD：获取报文首部，和GET很像但是不返回报文主体，幂等操作

POST: 创建或更新资源，非幂等操作

PUT: 创建或更新资源本身，幂等操作

PATCH：对资源进行局部更新，非幂等操作

DELETE：删除资源，和PUT功能相反，幂等操作

OPTIONS：查询服务器端支持的HTTP方法种类(幂等操作)：

| 请求 | OPTIONS * HTTP/1.1 Host: lindaidai.wang                      |
| :--- | :----------------------------------------------------------- |
| 响应 | HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS (返回服务器支持的方法) |

CONNECT：建立连接隧道，用于代理服务器，幂等操作

TRACE：追踪请求，查询发出去的请求是怎样被加工/篡改的，幂等操作。容易引发XST跨站追踪攻击。

### HTTP中的幂等是什么

如果一个方法重复执行多次，产生的效果是一样的，那么这个方法就是幂等的。**「它本质上意味着成功执行请求的结果与其执行次数无关。」**

描述：一个方法是不是幂等，其实就是判断一个方法重复执行多次，产生的效果是不是一样的，如果是幂等的话，它本质上意味着成功执行请求的结果和它的执行次数无关。我所知道的，只有**「POST」**和**「PATCH」**是非幂等的，其它都是幂等操作。

### GET和POST的区别

- 从缓存的角度上说，GET会被浏览器主动缓存下来，留下历史记录，但是POST不会。
- 从编码的角度上说，GET只能进行URL编码，它只能接收ASCII字符，但是POST没有限制。
- 从参数的角度上说，GET一般放在URL上传递参数，POST放在请求体里，更适合传递敏感信息。
- 从幂等的角度上说，GET是幂等的，而POST不是。
- GET和POST本质上都是TCP连接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致它们在应用过程中体现出一些不同。
- 从TCP的角度上说，GET请求会把请求报文一次性发出去，但是POST会分为两个TCP数据包。首先发送的是header部分，若是服务器响应100(continue)，则会发送body部分，当然**「火狐」**浏览器除外，它的 POST 请求只发一个 TCP 包。

这时候面试官可能还会追加着问你：既然POST要分为两个TCP数据包发送，那GET是不是会比POST更有效啊）

你可以这样回答：

- 首先，GET和POST都有它们自己的语义的，最好不要混用
- 另外，虽然说POST会分为两个数据包发送，但是其实在网络条件好的情况下，发一次包和发两次包的相差的时间基本可以被无视了。并且在网络条件差的情况下，两次包的TCP在验证数据包的完整性上还有更大的优点。
- 再者，也并不是所有的浏览器的POST请求都会发送两次TCP数据包的，比如火狐就不会。









### 参考链接

- [ShutdownHTTP系列-基础篇](https://juejin.im/post/5e955817f265da47c06ecf77)
- [从输入URL开始建立前端知识体系](https://juejin.cn/post/6935232082482298911#heading-6)