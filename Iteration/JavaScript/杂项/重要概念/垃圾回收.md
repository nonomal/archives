对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。
当我们不再需要某个东西时会发生什么？JavaScript 引擎如何发现它并清理它？
## 要点
### 内存的生命周期
不管什么程序语言，内存生命周期基本是一致的：

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像 JavaScript 这些高级语言中，大部分都是隐含的。
当内存“不再需要”时需要释放，而对于“不再需要”这个问题JavaScript是无法精确的判定的，因此垃圾回收其实也只能有限制的解决一部分问题。
### 可达性
简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。

1. **一些固有的可达值的集合**
- 当前执行的函数，它的局部变量和参数
- 当前嵌套调用链上的其他函数、它们的局部变量和参数
- 全局变量
- 还有一些内部的
2. **如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的**

比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 **该** 对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。
一个简单的例子：
```javascript
// user 具有对这个对象的引用
let user = {
  name: "John"
};
```
这里的箭头描述了一个对象引用。全局变量 "user" 引用了对象 {name："John"}（为简洁起见，我们称它为 John）。John 的 "name" 属性存储一个原始值，所以它被写在对象内部。
如果 user 的值被重写了，这个引用就没了：
```javascript
user = null;
```
#### 引用的情况
```javascript
// user 具有对这个对象的引用
let user = {
  name: "John"
};

let admin = user;
user = null // 此时user已被清除，但admin还在内存中
```
#### 相互关联的对象
```javascript
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});

delete family.father;
delete family.mother.husband; 
// 此时John和Ann还在内存中
```
### 内部算法
从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进，并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。
垃圾回收的基本算法被称为 “mark-and-sweep”。标记清除法
定期执行以下“垃圾回收”步骤：

- 垃圾收集器找到所有的根，并“标记”（记住）它们。
- 然后它遍历并“标记”来自它们的所有引用。
- 然后它遍历标记的对象并标记 **它们的** 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
- ……如此操作，直到所有可达的（从根部）引用都被访问到。
- 没有被标记的对象都会被删除。
### V8的垃圾回收
#### 分代收集
在 **V8** 中会把堆分为两个区域：

- **新生代**：新生代中存放的是 **生存时间短** 的对象，通常只支持 **1～8M** 的容量
- **老生代**：老生代中存放的 **生存时间久** 的对象，支持的容量就比新生代大很多

对于这两块区域，**V8** 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：

- **副垃圾回收器**：主要负责 **新生代** 的垃圾回收
- **主垃圾回收器**：主要负责 **老生代** 的垃圾回收
##### 工作流程
对于主副垃圾回收器，他们 都有一套共同的执行流程
**第一步** 是 **标记** 空间中 **活动对象** 和 **非活动对象**
**第二步** 是 **回收非活动对象所占据的内存**
**第三步** 是做 **内存整理**

- 频繁回收对象后，内存中就会存在大量不连续空间，即 **内存碎片**
- 内存中出现大量的 **内存碎片**，可能会导致被后期分配内存时出现 **内存不足** 的情况
- 注意 **副垃圾回收器** 不会产生 **内存碎片**
### 垃圾回收算法分类

- GC标记-清除算法

GC标记-清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这两个阶段，就可以令不能利用的内存空间重新得到利用

- 引用计数法

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
```javascript
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```

- GC复制算法 
- GC标记-压缩算法
- 保守式GC
- 分代垃圾回收
- 增量式垃圾回收
- RC lmmix算法
### 会导致内存泄漏的情况
JavaScript 内存泄漏是指当一些不在需要的对象继续占用着内存，而这些内存无法被 GC（垃圾回收机制）回收时就出现了内存泄漏。
JavaScript 中常见的内存泄漏的情况包括：

1. ** 意外的全局变量**，没有通过 var、let、const 等关键字声明的变量，会挂载在全局上，无法被 GC 回收。 
2.  **闭包**，当一个函数返回了一个嵌套的函数，而这个嵌套的函数中引用了外层函数的变量时，外层函数的变量将一直存在于内存中，无法被 GC 回收。 
3.  **定时器**，定时器可能引用了一些需要释放的对象或变量，如果没有在合适的时候清除定时器，这些对象或变量将一直存在于内存中。 
4.  **DOM 引用**，如果没有及时清除 DOM 节点的引用，这些节点会一直存在于内存中，导致内存泄漏。 
5.  **循环引用**，当两个对象互相引用时，即使这两个对象没有被其他对象引用，它们也无法被 GC 回收。
### 内存泄漏识别方法

1. 打开开发者工具，选择 Memory
2. 在右侧的Select profiling type字段里面勾选 timeline
3. 点击左上角的录制按钮。
4. 在页面上进行各种操作，模拟用户的使用情况。
5. 一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。
## 总结
### JavaScript的垃圾回收的理解
**是什么？**
JavaScript的垃圾回收机制通过自动化的方式管理内存使用，以便确保JavaScript程序在运行时具有足够的内存。
**做了什么？**
JavaScript引擎会定期检查内存中的对象，并标记那些可以被释放的对象。一旦一个对象被标记为不再使用，JavaScript引擎就会释放该对象占用的内存，以便其他对象可以使用该内存。 
**有哪些？**
在JavaScript中，有两种垃圾回收算法：**标记清除和引用计数。**
标记清除算法的工作原理是，JavaScript引擎会标记所有活动对象，然后清除不再使用的对象。
引用计数算法记录每个对象被引用的次数，当一个对象的引用计数为零时，该对象就被释放。 JavaScript引擎会在浏览器空闲时（例如，当用户停止交互时）运行垃圾回收算法。
因此，程序员不必担心手动释放内存，而只需要按照最佳实践编写代码，以便确保对象得到正确地管理和清除。
### 什么是内存泄漏
程序在运行过程中，分配的内存空间没有被及时释放，导致系统中存在一些“无用”的内存块，而这些内存块在程序运行过程中**不能被重新分配使用(代码逻辑对它失去了控制权)**，因此会占用越来越多的系统内存资源，最终导致系统崩溃或者程序出现不可预知的错误。内存泄漏一般是由于程序中存在程序逻辑错误、资源管理不当、使用了低效的算法等原因所造成的。
## 资料

- [垃圾回收算法的实现-V8的垃圾回收](https://weread.qq.com/web/reader/82632d50718ff64b82667f3kb6d32b90216b6d767d2f0dc)
- [https://zh.javascript.info/garbage-collection](https://zh.javascript.info/garbage-collection)
- [V8 如何进行垃圾回收？_前端码农小王的博客-CSDN博客](https://blog.csdn.net/qq_53225741/article/details/125330813)
- [彻底弄清楚V8垃圾回收的流程 - 掘金](https://juejin.cn/post/6844904100677550094)
- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)
- [赠你13张图，助你20分钟打败了「V8垃圾回收机制」！！！](https://segmentfault.com/a/1190000041218998) ⭐️

