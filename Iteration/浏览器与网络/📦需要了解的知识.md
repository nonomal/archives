## 问题
### 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？
点击刷新按钮或者按 F5：浏览器直接对本地的缓存文件过期，但是会带上 If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是200。
用户按 Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。 
地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。
### 常见的浏览器内核

1. Trident：这种浏览器内核是 IE 浏览器用的内核
2. Gecko：这是 Firefox 和 Flock 所采用的内核，功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。
3. Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3 倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。
4. Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于Gecko 和Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是KDE 小组的KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支
5. Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实Blink引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到 140 过的，Opera 弃用了自己的 Presto 内核，加入Google 阵营，跟随谷歌一起研发 Blink
### 渲染过程遇到JS文件如何处理？
JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。
也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，**并不是说 script 标签必须放在底部**，因为你可以给script 标签添加defer 或者 async 属性。
### 对语义化的理解
语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。
语义化的优点如下： 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于 SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。
### DOCTYPE(⽂档类型) 的作⽤
DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html 或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对CSS 代码甚⾄JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。
浏览器渲染页面的两种模式（可通过 document.compatMode 获取)
CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。 
BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。
### 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？
在线的情况下，浏览器发现 html 头部有`manifest` 属性，它会请求manifest 文件，如果是第一次访问页面，那么浏览器就会根据manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest 文件与旧的manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器会直接使用离线存储的资源。
### Canvas 和 SVG 的区别
SVG 可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言 XML 描述的 2D 图形的语言，SVG 基于XML 就意味着SVGDOM中的每个元素都是可用的，可以为某个元素附加Javascript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形。
其特点如下： 

- 不依赖分辨率 
- 支持事件处理器
- 最适合带有大型渲染区域的应用程序（比如谷歌地图）
- 复杂度高会减慢渲染速度（任何过度使用DOM 的应用都不快）
- 不适合游戏应用

Canvas 是画布，通过 Javascript 来绘制2D 图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。
其特点如下： 

- 依赖分辨率 
- 不支持事件处理器 
- 弱的文本渲染能力
- 能够以 .png 或 .jpg 格式保存结果图像
- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘
### 图片转为base64为什么会变大
Base64 是基于 64 个可打印字符来表示任意二进制数据的方法。
Base64 通常用于数据加密或签名后转换为可见字符串，文本资源(如 HTML 和 CSS 中)中嵌入图片文件等等。
原理是把二进制数据每 3 个字节重新划为 4 组(每三个 8 位字节,即总共24位,可以由四个 6 位 Base64 数值表示)，然后作为索引查编码表，获得相应的字符，从而得到编码后的字符串。
经过 Base64 编码后数据会增大，因为每 3 个字节，重新划分为 4 个字节，数据大小会变为原来的 4/3, 因此数据增大 1/3。
Base64 是一种通过索引查表的编码方法，不能用于加密。
### HTML5 drag API
dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。
darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 
drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。
### 网站图片文件，如何点击下载？而非点击预览？
```css
<a href="logo.jpg" download>下载</a>
<a href="logo.jpg" download="网站LOGO">下载</a>
```


## 资料

- [「如何从零到一实现一个玩具浏览器🌏」-阿里云开发者社区](https://developer.aliyun.com/article/912091)
- [JavaScript与有限状态机 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html)
- [肝完《浏览器基本原理与实践》后，我总结了这 36 点](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651614613&idx=2&sn=a9e34f2237a9f6faa7832e1e8a800a3e&chksm=8022ba54b7553342d8fb5d24c29a3093042793cacf6dcb49df4b154a4652b3751c980c06a8e3#rd)


